<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Notes for better_tutorial in Nasm]]></title>
    <url>%2F2019%2F05%2F20%2FNotes%20for%20better_tutorial%20in%20Nasm%2F</url>
    <content type="text"><![CDATA[This note is based on the tutorial of this project Chapter 1 &amp; 2NASM Data Type Type Meaning Size db Define byte 1 byte dw Define word 2 bytes dd Define double word 4 bytes dq Define quad word 8 bytes dt Define ten bytes 10 bytes global directive NASM specific entry point in executable file default entry point name: _start to change the entry point name, specify -e parameter ld -e my_entry_point -o out a.o int 80h &amp; syscall syscall is invalid on 32-bit , only on x86-64 int 0x80 is a legacy way to invoke a system call and should be avoided. vSDO: 1 2 sysenter CR/LF 0Ah is Line Feed character, equals\n. 將游標向下移，但不回到句首 0Dh is Carriage Return character, equals \r. 將游標移到該行的句首 Chapter 3CMPcmp destination, source 其實就等於 destination - source CMP instruction would change Zero, Carry, Overflow, Auxiliary and Parity flags. Unsigned integer operation CMP Results ZF CF Destination &lt; Source 0 1 Destination &gt; Source 0 0 Destination = Source 1 0 Signed integer operation CMP Results Flags Destination &lt; Source SF = OF Destination &gt; Source SF ≠ OF Destination = Source ZF = 1 JZjz &lt;label&gt; jump to label if ZF = 1 INCinc operand operand + 1 byte EFLAGS RegisterZero FlagThe flag is set when the result of an operation generates a result of zero Carry Flag Unsigned arithmetic operation The flag is set in two situations 兩者相加的結果（大小）大於Register能存放的空間 當小數減掉大數時。 00000001 - 00000010 = 11111111 and CF is set (表示負號，因為是Unsigned) Overflow Flag與Carry Flag相同，但用於Signed arithmetic operation Auxiliary FlagSign Flagwhen the result of an operation generates a negative result Parity Flag以11101101做例子，因為有6個1，是偶數個，所以PF=1 Chapter 5%include &quot;&lt;filename.inc&gt;&quot; Include other source files into current code，類似C的include. Reference Chapter 6sys_write 以 0h (NULL byte) 作為string終止符號(而非0Ah or 0Dh)。所以如果想要sys_write在data段某個string，但是若每一個string最後都沒有以0h做結尾，那將會印出從給予位置到第一個null byte才會結束。 Chapter 9Section .bss Block Started by Symbol 用於存放尚未初始化的變數。該段通常只包含變數名以及其長度(大小) e.g. 123456SECTION .bssvariableName1: resb 1 ;reserve one bytevariableName2: resw 1 ;reserve one wordvariableName3: resd 1 ;reserve one double wordvariableName4: resq 1 ;reserve one quad wordvariableName5: rest 1 ;reserve one extended precision float sys_read eax 3 ebx 0 : read from file descriptor STDIN ecx : address of the reserved space edx : number of bytes to read Chapter 11div (unsigned division)$dest ← dest \div source$ Dividend Divisor Quotient Remainder AX r/m8 AL AH DX:AX r/m16 AX DX EDX:EAX r/m32 EAX EDX RDX:RAX r/m64 RAX RDX Example 1234567891011SECTION .datadividend dq 0000000800300020hdivisor dd 00000100hSECTION .text global _start_start: mov edx, [dividend+4] mov eax, [dividend] div dword [divisor] ; need to specify the size of the content by using memory address idiv (Signed divide) Chapter 12add dest, source $dest ← dest + source$ EFLAGS are set according to the result Check this table to find available combination of dest and source Chapter 13sub dest, source $dest ← dest - source$ Chapter 14mul src $eax ← eax \times src$ Chapter 16Initial Process Stack當主程式開始前，OS(exec)會先初始化stack，使其包含一些重要的資訊，如下： High Address other system stuff … Auxiliary Vectors 4 words each Zero doubleword Address of last environment argument … Address of environment argument 2 Address of environment argument 1 doubleword Zero doubleword Address of Last Argument … Address of Argument 2 Address of Argument 1 doubleword Argument Count [esp] doubleword Low Address esp的位址一開始會存放argument的總數。而接下來存放的都是各argument的位址。Argument1預設是放置該程式的路徑，所以user輸入的參數會是從Argument2開始。 在tutorial中，利用pop可以依序得到user輸入的command line argument。 Reference 1 2 Set register to zeroxor reg, reg 該instruction是比較建議的方式來將register歸零，而非mov reg, 0 12345xor reg 10110110 10110110 ------------ 00000000 Refer 在gdb中輸入command line argumentgdb --args executable_name arg1 arg2 arg3 Refer Chapter 17local labels透過namespace使相同名字的label能夠重複使用，如下 1234567891011label1: .loop: ... jmp .loop ;這會跳到label1底下的.loop而非label2底下的.loop label2: .loop: ... jmp .loop jmp label1.loop ;當從其他地方要呼叫時，只要將global label(namespace)配上local label即可access Reference Chapter 19sys_execveexecutes a new program. eax 11 ebx address of the file ecx address of arguments edx address of the environment variables the address points to the variable in the section .data （其實該函數可以討論的更深，但我覺得之後研究OS再深入做筆記） Chapter 20sys_forkinvoke a child process eax 2 After invoking sys_fork, if eax is 0, then it implies that the current process is a child process.]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>NASM</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notes for Computer Networking 6e]]></title>
    <url>%2F2019%2F04%2F30%2FNotes%20for%20Computer%20Networking%206e%2F</url>
    <content type="text"><![CDATA[Chapter 2 - Application LayerDNS Goal: To resolve a fully qualified domain name (FQDN) to an IP address. This process is called name resolution. Runs over UDP and uses Port 53 DNS other important services: Host Aliasing and Load Balance A DNS recursive query is between a DNS client and its local DNS server. When local DNS server can’t resolve a new name from its own database, it would make an iterative query to other DNS servers. DNS server 可以設定fowarder，等於是將別人的query丟給另一台DNS server。若Client搜尋時，一直有Non-authoritative answer，那可能就是local DNS server只是forward給其他DNS server BIND (Berkeley Internet Name Domain)互聯網上最常使用的DNS軟件，占所有DNS服務器的九成 Zone fileA zone file is a sequence of entries for resource records. Each line is a text description that defines a single resource record | name | ttl | record class | record type | record data | record class: namespace of the record information, most commonly used namespace is Internet (IN) record type Type=SOA (Start of Authority): 定義於Zone file的開頭，描述關於zone的基本資訊 Type=A: (hostname, IP) Type=NS: (Domain Name, Authoritative DNS Server) Type=CNAME: (Domain Name, Canonical hostname) Type=PTR: 反查IP的Domain Name Type=AXFR: Zone Transfer Zone Transfer: Available for administrators to replicate DNS databases across a set of DNS servers for backup Security Concerns : 利用zone transfer去找所有可以攻擊的切入點 nslookup Get manual page: man nslookup 123456789101112131415161718192021222324252627282930&gt; server 8.8.8.8 (set default server)Default server: 8.8.8.8Address: 8.8.8.8#53-------------------------&gt; set all (show all settings)&gt; set debug (顯示DNS Message)-------------------------&gt; set type=any (將全部各類型的RR都顯示出來)&gt; google.comServer: 8.8.8.8Address: 8.8.8.8#53Non-authoritative answer: (存在於local DNS Server cache中)Name: google.comAddress: 172.217.27.142-------------------------&gt; set norecurse (若local dns server沒有cache就回傳Nothing)&gt; www.hs.fiServer: 8.8.8.8Address: 8.8.8.8#53** server can&apos;t find www.hs.fi: REFUSED&gt; set recurse&gt; www.hs.fiServer: 8.8.8.8Address: 8.8.8.8#53Non-authoritative answer:Name: www.hs.fiAddress: 54.192.146.52 hosthost [-al] FQDN -a : 等於nslookup set debug -l : 等於nslookup set type=axfr dig123&gt; dig +trace google.com @168.95.192.1 (追蹤經過哪些節點，並利用168.95.192.1作為server) &gt; dig -x 168.95.192.1 (等於nslookup type=PTR)&gt; dig -t [type] FQDN (指定RR type) whois顯示該domain name的管理者資訊&gt; whois FQDN /etc/hosts file 作用與DNS類似。例如瀏覽器在搜尋網址時會先找該檔案的設定，如果沒有才問DNS server。 格式: [IP] [hostname] [hostname別名]e.g. 127.0.0.1 localhost hostname用於顯示或修改system的host name，儲存於/etc/hostname or /proc/sys/kernel/hostname 12345&gt; hostname (顯示host name) mac.local &gt; hostname -i (顯示hostname的IP) 127.0.1.1 &gt; hostname [name] (設置臨時hostname) gethostbyname()Chapter 3 - Transport LayerUDP (User Datagram Protocol)Headers (8 bytes) Source Port Destination Port Length (header plus data) Checksum At the sender side performs the 1s complement of the sum of all the 16-bit words(2 bytes) in the segment, with any overflow encountered during the sum being wrapped around。也就是checksum = 將segment裡全部的16-bit words總合後，再 1&#39;s complement At the receiver, all four 16-bit words are added, including the checksum. 若總合後每一位不是都1，那就表示有錯誤發生。因為一個數字加上其1’s complement的值，一定是都是111111… wrap around： 將overflow的值拿到最低位再相加11011100-——-11001^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(overflow)-——-1101&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;(wrapped around)-——-1110 (answer) ##Reliable Data Transfer GBN (Go Back to N) 解決 Stop-and-wait s 12345678910110 Base Nextseqnum Base+N |---------|-------------|---------------|---------------&gt; (1) (2) (3) (4) |-----------------------------| Window Size N(1) Already sent and ACKed(2) Sent, not yet ACKed(3) Usable, not yet sent(4) Not usable (不在sliding window中，所以還不能傳送) Receiver不需要buffer順序不對的packet Cummulative Acknowledgment （不是base的packet都不予理會） 使用一個Timer，該timer是綁定最早傳送但未ACKed的packet(Base Packet)。當Timeout Event發生時，需要重送全部已送過但未ACKed的封包 (Base ~ Nextseqnum-1) Selective Repeat Sender 允許ACKed但不是base的packet留在window裡 每個packet有自己獨立的timer Receiver Out-of-order packets會被buffer 當base packet到某一個packet都是in order且acked時，就會被delievered to upper layer Window size must be less than or equal to half the size of the sequence number space TCP Maximum Segment Size (MSS)]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Computer Networking</tag>
        <tag>DNS</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notes for NASM Learning]]></title>
    <url>%2F2019%2F04%2F30%2FNotes%20for%20NASM%20Learning%2F</url>
    <content type="text"><![CDATA[CommandMacOS64-bit123&gt; nasm -f macho64 &lt;filename.asm&gt; -o &lt;object_filename.o&gt; &gt; ld -macosx_version_min 10.7.0 -lSystem -o &lt;executable&gt; &lt;object_filename.o&gt; &gt; ./&lt;executable&gt; 32-bit123&gt; /usr/local/bin/nasm -f macho &lt;filename.asm&gt; -o &lt;object_filename.o&gt; &gt; ld -macosx_version_min 10.7.0 -o &lt;executable&gt; &lt;object_filename.o&gt; &gt; ./&lt;executable&gt; Linux64-bit123&gt; nasm -f elf64 &lt;filename.asm&gt; -o &lt;object_filename.o&gt; &gt; ld -o &lt;executable&gt; &lt;object_filename.o&gt; &gt; ./&lt;executable&gt; 32-bit123&gt; nasm -f elf &lt;filename.asm&gt; -o &lt;object_filename.o&gt; &gt; ld -m elf_i386 -o &lt;executable&gt; &lt;object_filename.o&gt; &gt; ./&lt;executable&gt; 加上 -m elf_i386，set emulation to 32-bit。在64-bit上的電腦compile 32-bit的檔案時，需加上這行。 System Call Table Reference for MacOS first column is system call number System Call Table for linux 32-bit System Call Table for linux 64-bit find . -name &#39;syscall.h&#39; 在mac 64-bit時，呼叫syscall時，需要rax = Code + 0x2000000 e.g. sys_write =&gt; 0x2000004 Notes!! 在32-bit MacOS上呼叫syscall與linux不同。MacOS 是將參數丟到stack上然後呼叫syscall，而非丟到register，所以無法直接將Linux 32-bit nasm code拿到MacOS上。解釋點我 objdumpOptions -i 列出可支援-b的檔案格式和-m的架構 -f 顯示File header資訊。 e.g. File format, architecture, flags and start address -h 顯示Section Header。 e.g. .text .data -t 顯示Symbol Table -p 顯示Program Header Table -x combination of -f -h -t -p -d 反組譯 code section -D 反組譯 ALL section -b 反組譯指定的BFD格式 -m 反組譯用的架構 readelf 與objdump的區別 不提供反組譯 不借助BFD，直接讀取ELF file → 訊息比較多 Options -a equivalent to: -h -l -S -s -r -d -V -A -I addr2lineTranslate an address in an executable or an offset in a section of an object file into file names and line numbers nasm在編譯時，必須加上-g (to generate debug information)。addr2line only supports functions that have debug information Options -a [addr, addr2..] -e filename the name of the executable -p pretty print]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>NASM</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ford–Fulkerson Algorithm for Maximum Flow Problem]]></title>
    <url>%2F2016%2F12%2F23%2FFord%E2%80%93Fulkerson%20Algorithm%20for%20Maximum%20Flow%20Problem%2F</url>
    <content type="text"><![CDATA[Given a graph which represents a flow network where every edge has a capacity. Also given two vertices source s and sink t in the graph, find the maximum possible flow from s to t with following constraints: a) Flow on an edge doesn’t exceed the given capacity of the edge. b) Incoming flow is equal to outgoing flow for every vertex except s and t. 首先，給予各點之間的關係（construct an adjacent list)基本的找法是： 尋找一條從s -&gt; t 的有效路徑 (BFS or DFS) 找到此路徑能通過的最小flow，更新Residual Graph 將flow加到 max_flow 結束後，return max_flow Residual Graph：一開始先複製original graph，而其點與點之間存放的是“剩餘可以通過的Flow (residual capacity)”。 換句話說，每當找到一條路徑可以是flow通過時，假設某edge的capacity 是 C，而通過的flow 是 F，則將更新此edge於該Residual Graph成 C-F，若是C-F=0，代表此edge不能再被挑選，因為沒有剩餘的quota。 需要注意的是，在更新residual某條edge時，假設是從u -&gt; v，則u -&gt; v 將被減掉 F，但是反方向 v -&gt; u 卻要增加F (起初反方向是0)，這個動作叫做”Cancellation”。 各Node的進出要維持不變 以下圖為例 （整條黑色路徑假設是s -&gt; b -&gt; v -&gt; a -&gt; c -&gt; t） 現在先看上面那條，若要推送一個10 flow時，在更新 10 flow / 15 capacity這條路徑時（設u -&gt;(10/10)a -&gt;(10/15) v)，則u-&gt;v在 Residual Graph上應該被減去10 ，剩餘5 ；但在反方向 v -&gt; u 這邊，卻要增加10。 之所以如此，我們可以看到若是在選擇上面那條後，準備要選擇中間這條路徑時 (u -&gt; b -&gt; v)，我們可以將 10/15 這條的5 搬移到上面的 0/9 ( a -&gt; c )，使其變成 5/9，而讓中間這條能夠傳一個Flow = 5至 v 再到 t ，對於v來說，輸入的還是總和還是10（守恆）。換個角度想，就好像是轉換跑道，從s -&gt; b -&gt; v -&gt; a -&gt; c -&gt; t。​ 所以，在更新時增加的flow (reverse direction)，可以當作是能夠被Cancel掉的quota。 From Geeksforgeeks ans: The maximum possible flow in the above graph is 23. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std; // Number of vertices in given graph#define V 6 /* Returns true if there is a path from source 's' to sink 't' in residual graph. Also fills parent[] to store the path */bool bfs(int rGraph[V][V], int s, int t, int parent[])&#123; // Create a visited array and mark all vertices as not visited bool visited[V]; memset(visited, 0, sizeof(visited)); // Create a queue, enqueue source vertex and mark source vertex // as visited queue &lt;int&gt; q; q.push(s); visited[s] = true; parent[s] = -1; // Standard BFS Loop while (!q.empty()) &#123; int u = q.front(); q.pop(); // if u = t, because all t's adjacent list elements are zero, no new element push to queue, queue will be empty for (int v=0; v&lt;V; v++) &#123; if (visited[v]==false &amp;&amp; rGraph[u][v] &gt; 0) &#123; q.push(v); parent[v] = u; visited[v] = true; &#125; &#125; &#125; // If we reached sink in BFS starting from source, then return // true, else false return (visited[t] == true);&#125; // Returns tne maximum flow from s to t in the given graphint fordFulkerson(int graph[V][V], int s, int t)&#123; int u, v; // Create a residual graph and fill the residual graph with // given capacities in the original graph as residual capacities // in residual graph int rGraph[V][V]; // Residual graph where rGraph[i][j] indicates // residual capacity of edge from i to j (if there // is an edge. If rGraph[i][j] is 0, then there is not) for (u = 0; u &lt; V; u++) for (v = 0; v &lt; V; v++) rGraph[u][v] = graph[u][v]; int parent[V]; // This array is filled by BFS and to store path int max_flow = 0; // There is no flow initially // Augment the flow while there is path from source to sink while (bfs(rGraph, s, t, parent)) &#123; // Find minimum residual capacity of the edges along the // path filled by BFS. Or we can say find the maximum flow // through the path found. int path_flow = INT_MAX; for (v=t; v!=s; v=parent[v]) &#123; u = parent[v]; path_flow = min(path_flow, rGraph[u][v]); &#125; // update residual capacities of the edges and reverse edges // along the path for (v=t; v != s; v=parent[v]) &#123; u = parent[v]; rGraph[u][v] -= path_flow; rGraph[v][u] += path_flow; &#125; // Add path flow to overall flow max_flow += path_flow; &#125; // Return the overall flow return max_flow;&#125; // Driver program to test above functionsint main()&#123; // Let us create a graph shown in the above example int graph[V][V] = &#123; &#123;0, 16, 13, 0, 0, 0&#125;, &#123;0, 0, 10, 12, 0, 0&#125;, &#123;0, 4, 0, 0, 14, 0&#125;, &#123;0, 0, 9, 0, 0, 20&#125;, &#123;0, 0, 0, 7, 0, 4&#125;, &#123;0, 0, 0, 0, 0, 0&#125; &#125;; cout &lt;&lt; "The maximum possible flow is " &lt;&lt; fordFulkerson(graph, 0, 5); return 0;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd Warshall Algorithm]]></title>
    <url>%2F2016%2F07%2F19%2FFloyd%20Warshall%20Algorithm%2F</url>
    <content type="text"><![CDATA[給一個有向圖(direct graph)，建立一個table，用以搜尋從one source to one destination最短路徑。 方法： 假設有N個點，從0開始一直挑到N-1，每次挑的時候，就把它納入intermediate set（一開始是空集合)。 納入之後，讓該點當作intermediate vertex，開始以這個intermediate vertex作為中繼站，試每個點到另一個點的最短路徑(N*N次），不斷更新該table。 意思就是若i - - - &gt; k - - - &gt; j 的distance &nbsp;&nbsp;&lt; &nbsp; &nbsp;i - - - &gt; j 的distance ，則更新該table’s i to j as table[i][k] + table[k][j] 當我們挑到k點時，表示我們已經考慮了0, 1, …. k-1個點了 example: from A to E B - - - - - 7- - - - - > E / / 5/ / 1 A - - 2 - - > C - - 3 ->D A-&gt;E distance1. 挑A， table[a][e]== INF is not allowed to test -12. 挑B，table[a][b] + table[b][e] &lt; table[a][e] == INF, let table[a][e]=12 123. 挑Ｃ，仍無法到達E，因Ｄ還沒在intermediate set，但更新了A-&gt;D為5 124. 挑D， table[a][d] + table[d][e] == 5+1 &lt; table[a][e] == 12 65. 挑E，table[a][e] + table[e][e], table[e][e]== INF is not allowed to test 6ans == 6 Floyd : City of Blinding LightsGiven a directed weighted graph where weight indicates distance, for each query, determine the length of the shortest path between nodes. There may be many queries, so efficiency counts. For example, your graph consists of 5 nodes as in the following: A few queries are from node 4 to node 3, node 2 to node 5 , and node 5 to node 3. There are two paths from 4 to 3: $4 \Rightarrow 1 \Rightarrow 2 \Rightarrow 3$ at a distance of **4 + 5 + 1 = 10** $4 \Rightarrow 1 \Rightarrow 5 \Rightarrow 3$ at a distance of **4 + 3 + 2 = 9** In this case we choose path 2 There is no path from 2 to 5, so we return -1. There is one path from 5 to 3: $4 \Rightarrow 5$ at a distance of **2** Input Format First line has two integers N, denoting the number of nodes in the graph and M, denoting the number of edges in the graph. The next M lines each consist of three space separated integers x y r , where x and y denote the two nodes between which the directed edge ( x -&gt; y ) exists, r denotes the length of the edge between the corresponding edges.The next line contains a single integer Q , denoting number of queries. The next Q lines each, contain two space separated integers a and b, denoting the node numbers specified according to the question. Constraints $2 \leqslant N \leqslant 400$ $1 \leqslant M \leqslant frac{N*(N-1)}{2}$ $1 \leqslant Q \leqslant 10^5$ $1 \leqslant x,y \leqslant N$ $1 \leqslant r \leqslant 350$ If there are edges between the same pair of nodes with different weights, the last one (most recent) is to be considered as the only edge between them. Output Format Print Q lines, each containing a single integer, specifying the shortest distance between the nodes specified for that query in the input. If the distance between a pair of nodes is infinite (not reachable), then print -1 as the shortest distance. Sample Input 4 5 1 2 5 1 4 24 2 4 6 3 4 4 3 2 7 3 1 2 3 1 1 4 Sample Output 5 -1 11 Explanation The graph given in the test case is shown as : The nodes A,B,C and D denote the 1,2,3 and 4 node numbers. The shortest paths for the 3 queries are : A-&gt;B (Direct Path is shortest with weight 5) -1 (There is no way of reaching node 1 from node 3, hence unreachable) A-&gt;B-&gt;D (Indirect path is shortest with weight (5+6) = 11 units, the direct path is longer with 24 units length) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;using namespace std;void floyd(vector&lt; vector&lt;int&gt; &gt; graph)&#123; //Add all vertices one by one to the set of intermediate vertices. for(int k=0; k&lt;graph.size(); k++)&#123; // Pick all vertices as source one by one for(int i=0; i&lt;graph.size(); i++)&#123; // Pick all vertices as destination for the // above picked source for(int j=0; j&lt;graph.size(); j++)&#123; //either i to k or k to j is INT_MAX, there's no way to move from the source to destination //however if i==k || k==j, there's no need to consider it if(graph[i][k]!=INT_MAX &amp;&amp; graph[k][j]!=INT_MAX)&#123; if(graph[i][k]+graph[k][j]&lt;graph[i][j]) graph[i][j] = graph[i][k]+graph[k][j]; &#125; &#125; &#125; &#125; //print solution int q; cin&gt;&gt;q; while(q&gt;0)&#123; int c, d; cin&gt;&gt;c&gt;&gt;d; c--; d--; //need to consider that source and destination are the same, self to self if(c==d) cout&lt;&lt;0&lt;&lt;endl; //if destination is unreachable else if(graph[c][d]==INT_MAX) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;graph[c][d]&lt;&lt;endl; q--; &#125;&#125;int main() &#123; int N, M; cin&gt;&gt;N&gt;&gt;M; vector&lt; vector&lt;int&gt; &gt; graph(N, vector&lt;int&gt; (N)); for(int i=0; i&lt;N; i++) for(int j=0; j&lt;N; j++) graph[i][j] = INT_MAX; while(M&gt;0)&#123; int a, b, w; cin&gt;&gt;a&gt;&gt;b&gt;&gt;w; a--; b--; graph[a][b] = w; M--; &#125; floyd(graph); return 0;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Hackerrank</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Union-Find Algorithm]]></title>
    <url>%2F2016%2F07%2F12%2FUnion-Find%20Algorithm%2F</url>
    <content type="text"><![CDATA[The algorithm is used to detect a cycle in a undirected graph There are two ways to implement the algorithm, one of which has the worst case in linear time. First method: Worst case: linear time $O(n)$ If the question has N vertices and M edges, after creating a graph based on previous vertices and edges,now we create a parent list (length N, 每一個index代表vertices, 而存放數字代表其parent) and initialise it with -1 for each elements. 當我們要尋找某一個edge是否產生cycle時，利用edge的source and destination來查看是否產生。透過parent list，當我們在尋找某x時，就利用recursive來一直不斷地找到某一element的parent是-1，然後回傳該parent；同樣的方法，尋找y，若是回傳的parent和x 回傳的parent一樣，代表他們在同一個subset，​若是再加入x and y，就會產生Cycle​；若沒有，則將x的subset和y的subset併成一個subset。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// a structure to represent an edge in graphstruct Edge&#123; int src; int dest;&#125;;// a structure to represent a graphstruct Graph&#123; int V; int E; vector&lt;Edge&gt; edge;&#125;;// Creates a graph with V vertices and E edgesGraph* createGraph(int V, int E)&#123; Graph *graph = new Graph; graph-&gt;V = V; graph-&gt;E = E; graph-&gt;edge = vector&lt;Edge&gt;(E); return graph;&#125;int find(const vector&lt;int&gt; &amp;parent, int i)&#123; if(parent[i]==-1) return i; return find(parent, parent[i]);&#125;void Union(vector&lt;int&gt; &amp;parent, int x, int y)&#123; parent[x] = y;&#125;// The main function to check whether a given graph contains // cycle or notbool isCycle(Graph* graph, int V, int E)&#123; //用以尋找是否有cycle vector&lt;int&gt; parent(V, -1); for(int i=0; i&lt;E; i++)&#123; int x = find(parent, graph-&gt;edge[i].src); int y = find(parent, graph-&gt;edge[i].dest); if(x==y) return 1; Union(parent, x, y); &#125; return 0;&#125;int main()&#123;/* Let us create following graph 0 | 1 / \ / \ 2 - - - 3 */ int V = 4, E = 4; struct Graph *graph = createGraph(V,E); graph-&gt;edge[0].src = 0; graph-&gt;edge[0].dest = 1; graph-&gt;edge[1].src = 1; graph-&gt;edge[1].dest = 3; graph-&gt;edge[2].src = 1; graph-&gt;edge[2].dest = 2; graph-&gt;edge[3].src = 2; graph-&gt;edge[3].dest = 3; if(isCycle(graph, V, E)) cout&lt;&lt;"Has Cycle"&lt;&lt;endl; else cout&lt;&lt;"No Cycle"&lt;&lt;endl; return 0;&#125; 簡單看parent list的變化 V 0 1 2 3 p -1 -1 -1 -1 加入Edge 0 v0 -&gt; v1 &nbsp;&nbsp;將V0的parent 變成 1， V0 and V1 are now in the same subset V 0 1 2 3p 1 -1 -1 -1 加入Edge 1 v1 -&gt; v3 &nbsp;&nbsp; V0, V1 and V3 are now in the same subset V 0 1 2 3 p 1 3 -1 -1 加入Edge 2 v1 -&gt; v2 &nbsp;&nbsp;在find V1時，會回傳V3，所以改變的是V3的parent V 0 1 2 3 //V0, V1, V2 and V3 are now in the same subsetp 1 3 -1 2 加入Edge 3 v2 -&gt; v3 &nbsp;&nbsp; because V2 and V3 are in the same subset, if we add edge 3, a cycle will be created. 但是，以上方法可以看出，每次find的時候，會把自己屬於的subset全部跑過一遍，一直找到parent是-1的vertex，其worst case O(N) 該方法可以被optimised to O(logN), the technique is called ​union by rank​ 方法： 每個節點在初始時其parent都是自己，rank=0(每有比誰高或低） 每次搜尋兩個vertices，都會回傳他的root，若是root相同，代表兩點在同一個subset 並且在搜尋時，會使各parent和該Node的parent都成為該subset的root (path compression)，這樣子下次再做搜尋時，可以直接找到該subset的root，由此好好利用每一次的搜尋 若是兩點不在同一個subset，代表現在若要加一條edge，那個兩點之subset會合併成同一subset 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;vector&gt;struct Edge&#123; int src; int dest;&#125;;struct Graph&#123; int V; int E; vector&lt;Edge&gt; edge;&#125;;struct subset&#123; int parent; int rank;&#125;;Graph* createGraph(int V, int E)&#123; Graph *graph = new Graph; graph-&gt;V = V; graph-&gt;E = E; graph-&gt;edge = vector&lt;Edge&gt;(E); return graph;&#125;int find(vector&lt;subset&gt; &amp;subsets, int i)&#123; // find root and make root as parent of i (path compression) if(subsets[i].parent!=i) subsets[i].parent = find(subsets, subsets[i].parent); return subsets[i].parent;&#125;void Union(vector&lt;subset&gt; &amp;subsets, int xroot, int yroot)&#123; // Attach smaller rank tree under root of high rank tree if(subsets[xroot].rank &lt; subsets[yroot].rank) subsets[xroot].parent = yroot; else if(subsets[xroot].rank &gt; subsets[yroot].rank) subsets[yroot].parent = xroot; // If ranks are same, then make one as root and increment // its rank by one else&#123; subsets[xroot].parent = yroot; subsets[yroot].rank++; &#125;&#125;bool isCycle(Graph* graph, int V, int E)&#123; vector&lt;subset&gt; subsets(V); for(int v=0; v&lt;V; v++)&#123; subsets[v].parent = v; subsets[v].rank = 0; &#125; // Iterate through all edges of graph, find sets of both // vertices of every edge, if sets are same, then there is // cycle in graph. for(int i=0; i&lt;E; i++)&#123; int x = find(subsets, graph-&gt;edge[i].src); int y = find(subsets, graph-&gt;edge[i].dest); if(x==y) return 1; Union(subsets, x, y); &#125; return 0;&#125;int main()&#123; int V = 4, E = 4; struct Graph *graph = createGraph(V,E); graph-&gt;edge[0].src = 0; graph-&gt;edge[0].dest = 1; graph-&gt;edge[1].src = 1; graph-&gt;edge[1].dest = 3; graph-&gt;edge[2].src = 1; graph-&gt;edge[2].dest = 2; graph-&gt;edge[3].src = 2; graph-&gt;edge[3].dest = 3; if(isCycle(graph, V, E)) cout&lt;&lt;"Has Cycle"&lt;&lt;endl; else cout&lt;&lt;"No Cycle"&lt;&lt;endl; return 0;&#125; 可參考：http://www.csie.ntnu.edu.tw/~u91029/Set.html 同樣方法不同說法]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Indexed Tree]]></title>
    <url>%2F2016%2F07%2F02%2FBinary%20Indexed%20Tree%2F</url>
    <content type="text"><![CDATA[給予一個陣列arr，在有以下兩個請求時，可以透過binary indexed tree 加速運算速度 (Update) add x to arr[index] (Sum) find the sum from arr[L] to arr[R] $index=1...N$ $f[i]=$ **frequency of each index ** $c[i]=$ **cummulation from index 1 to index i** $tree[i]=$ 在tree各自負責區段的總和 usually we will set index 0 as dummy, f[0]=0, c[0] =0 num 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16f 1 0 2 1 1 3 0 4 2 5 2 2 3 1 0 2c 1 1 3 4 5 8 8 12 14 19 21 23 26 27 27 29tree 1 1 2 4 1 4 0 12 2 7 2 11 3 4 0 29 BIT (according to the graph above) 在BIT當中，每一個Node都存放著自己負責“區段”的總和。 將index轉換成binary representation後，透過binary number有幾個1，來尋找從$1 \Rightarrow index$的總和 若某一個Node的index = idx， 則其存放的總和 $= idx - 2^r +1 \Rightarrow idx$ ( r是該idx從左而右最後一個1的位置） e.g. 譬如idx = 13; 13 = 01101， 最後一個1的位置是0th（由右而作從零開始，所以Node 13負責的總和為 $index = 13-2^0+1 = 13 \Rightarrow 13$，負責自己的Node) (if idx = 12, 其負責的總和為$index = 12-2^2+1 = 9 \Rightarrow 12$) 換句話說，就是 (自己的left subtree + 自己的frequency) 若要求得c[13] = c[01101] = tree[01101] + tree[01100] + tree[01000] 由此可知，皆是從Node移動到Root BIT的主要概念即是給一個index 轉換成binary後，若要得知從1至該index的總和，就是把binary index 從右至左每次把最右邊的1砍掉後（刪去最低為的1)，全部的總和。 如此作法可以比通常各Node是從1……index全部加起來還要快，因為此方法是看binary index 中有多少個1，就加多少個Node即可，不需要從頭到尾累加。 只可以更新數值，不能插入新的節點 如何得到最低位的1(Rightmost Set bit) ?index &amp; -index Proof: if index = A(anything)1B(all zero) = (…101110101) 1 (000000000….) -index = (A1B)¯ + 1 **(to get the negative binary number of a specific index, take complement and add 1) num**¯ = complement of num ** = A¯0B¯ + 1 (since B = (1111111…), if we add 1, then B = (000000), and 0 becomes 1)** ** = ***A¯1B * Sum:given an index, go from node to root to find the summation 從BIT 樹圖分析， 從Node開始，若是這個Node是parent 的left tree, 則不需要將sum+=tree[index] 若是這個Node是parent 的right tree, 則需要將sum+=tree[index] 12345678int getSum(const vector&lt;int&gt; &amp;BIT, int index)&#123; int sum = 0; while(index&gt;0)&#123; sum += BIT[index]; index -= (index &amp; -index); //刪去最低位的1 &#125; return sum;&#125; Update:跟Sum類似，更新有負責(包含)到該index的Node 換句話說，若是該Node是parent’s left child的話，則需要更新parent 若是該Node是parent’s right child的話，則不需要更新parent 123456int update(vector&lt;int&gt; BIT, int index, int addition)&#123; while(index &lt; BIT.size())&#123; //index &lt; size of the tree BIT[index] += addition; index += (index &amp; -index); //將最低位的1加1，就可以找到parent &#125;&#125; Get single node frequency最直覺的方式就是 f[index] = c[index] - c[index-1]，意思就是跑兩次Sum; 但如何可以只跑一次就好？ c[index] 和 c[index-1] 一定有相同的 if index = x = A1B¯ , then y = index - 1 = A0B 從這邊可以看出 c[x] = c[A0B¯] + tree[A1B¯] , c[y] = c[A0B¯] + tree[A0(111…111)] + tree[A0(111..110] + tree[A0(111..100] + ……… =&gt; c[x] - c[y] = tree[A1B¯] - { tree[A0(111…111)] + tree[A0(111..110] + tree[A0(111..100] + ………} 所以當y開始一直刪去最低位的1後，最後 y 會變成A0B¯(common predecessor ) ，也就是停止的時候。 ＊換句話說，將x負責的區段一直刪去只剩下f[x]而已 12345678910int getFrequency(vector&lt;int&gt; BIT, int index)&#123; //index!=0 int sum = BIT[index]; //set sum = tree[index] int common_pre = index - (index &amp; -index); //find common predecessor index--; //index is not important anymore, we could use it as our variable while(index != common_pre)&#123; //after deleting the rightmost set bit, it will become common_pre sum -= BIT[index]; index -= (index &amp; -index); &#125; return sum;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iomanip&gt;using namespace std;int getSum(const vector&lt;int&gt; &amp;BIT, int index)&#123; int sum = 0; while(index&gt;0)&#123; sum += BIT[index]; index -= (index &amp; -index); //刪去最低位的1 &#125; return sum;&#125;void update(vector&lt;int&gt; &amp;BIT, int index, int addition)&#123; while(index &lt; BIT.size())&#123; //index &lt; size of the tree BIT[index] += addition; index += (index &amp; -index); //將最低位的1加1，就可以找到parent &#125;&#125;int getFrequency(vector&lt;int&gt; BIT, int index)&#123; //index!=0 int sum = BIT[index]; //set sum = tree[index] int common_pre = index - (index &amp; -index); //find common predecessor index--; //index is not important anymore, we could use it as our variable while(index != common_pre)&#123; //after deleting the rightmost set bit, it will become common_pre sum -= BIT[index]; index -= (index &amp; -index); &#125; return sum;&#125;void printTree(const vector&lt;int&gt; &amp;BIT)&#123; cout&lt;&lt;"i "; for(int i=1; i&lt;BIT.size(); i++) cout&lt;&lt;setw(3)&lt;&lt;i; cout&lt;&lt;endl; cout&lt;&lt;"F "; for(int k=1; k&lt;BIT.size(); k++) cout&lt;&lt;setw(3)&lt;&lt;getFrequency(BIT, k); cout&lt;&lt;endl; cout&lt;&lt;"C "; for(int t=1; t&lt;BIT.size(); t++) cout&lt;&lt;setw(3)&lt;&lt;getSum(BIT, t); cout&lt;&lt;endl; cout&lt;&lt;"Tree "; for(int p=1; p&lt;BIT.size(); p++) cout&lt;&lt;setw(3)&lt;&lt;BIT[p]; cout&lt;&lt;endl;&#125;vector&lt;int&gt; constructBIT(int arr[], int N)&#123; vector&lt;int&gt; BIT(N+1); for(int i=0; i&lt;=N; i++) BIT[i] = 0; //initialize tree for(int j=0; j&lt;N; j++) update(BIT, j+1, arr[j]); return BIT;&#125;int main(int argc, char const *argv[])&#123; int N = 16; //length of frequecy array int freq_arr[] = &#123; 1, 0, 2, 1, 1, 3, 0, 4, 2, 5, 2, 2, 3, 1, 0, 2&#125;; //given data vector&lt;int&gt; BITree = constructBIT(freq_arr, N); /* use to demontrate */ printTree(BITree); return 0;&#125; Hackerrank: Similar PairA pair of nodes, (a,b), is a similar pair if both of the following conditions are true: Node a is the ancestor of node b $abs(a-b) \leqslant k$ Given a tree where each node is labeled from 1 to n , find the number of similar pairs in the tree. For example, given the following tree: We have the following pairs of ancestors and dependents: 123456789Pair abs(a-b)1,2 11,3 21,4 31,5 41,6 53,4 13,5 23,6 3 If k=3 for example, we have 6 pairs that are similar, where $abs(a,b) \leqslant k$. Function Description Complete the similarPair function in the editor below. It should return an integer that represents the number of pairs meeting the criteria. similarPair has the following parameter(s): n: an integer that represents the number of nodes k: an integer edges: a two dimensional array where each element consists of two integers that represent connected node numbers Input Format The first line contains two space-separated integers n and k , the number of nodes and the similarity threshold.Each of the next n-1 lines contains two space-separated integers defining an edge connecting nodes p[i] and c[i], where node p[i] is the parent to node c[i]. Constraints $1 \leqslant n \leqslant 10^5$ $0 \leqslant k \leqslant n$ $1 \leqslant p[i], c[i] \leqslant n$ Output Format Print a single integer denoting the number of similar pairs in the tree. Sample Input 5 2 3 2 3 1 1 4 1 5 Sample Output 4 Explanation The similar pairs are (3,2), (3,1), (3,4), and (3,5), so we print 4 as our answer. Observe that (1,4) and (1,5) are not similar pairs because they do not satisfy $abs(a,b) \leqslant k$ for $k=2$. Solution 先建構好題目要的樹（不是BIT)。 BIT的用途是，透過存放parent index至BIT，使其Child在尋找他所需要的範圍時(child+k, child-k)，可以透過Sum，統計在這個範圍裡parent 的 total 每次訪問一個Node的時候，先問BIT該Node index的 index+k and index-K這個範圍當中，有多少，然後將加到similar pair 接著就將Node 的index 更新(該index於BIT +1) 然後再用Recursive 跑這個Node的Child 跑完全部該Node的child後，又更新一次Node index (-1) 所以由此可以確保每次訪問BIT時，BIT裡面的各Index一定是該Node的ancestor 如此可以不需要一個一個和parent比對，因為若有M個ancestor，則只需要花Olog(M)的時間來找到該Node的similiar pair，而非O(M) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//bt : bit array//i and j are starting and ending index INCLUSIVElong long bit_q(long long * bt,int i,int j)&#123; //尋找範圍裡的總數 long long sum=0ll; while(j&gt;0) &#123; sum+=bt[j]; j -= (j &amp; (j*-1)); &#125; i--; while(i&gt;0) &#123; sum-=bt[i]; i -= (i &amp; (i*-1)); &#125; return sum;&#125;//bt : binary indexed tree//n : size of bit array//i is the index to be updatedvoid bit_up(long long * bt,int n,int i,long long diff)&#123; while(i&lt;=n) &#123; bt[i] += diff; i += (i &amp; (i*-1)); &#125;&#125;int n,k;vector&lt;int&gt; al[100005]; //adjacency listlong long similar_pair;long long bit[100005]; //binary indexed treevoid dfs(int node)&#123; similar_pair += bit_q(bit,max(1,node-k),min(n,node+k)); bit_up(bit,n,node,1); //將該index在binary indexed tree 的值+1，換句話說就是將index push to bit for(int i=0; i&lt;al[node].size();i++) dfs(al[node][i]); bit_up(bit,n,node,-1);&#125;int main() &#123; int x,y; cin&gt;&gt;n&gt;&gt;k; similar_pair=0; //answer for(int i=0;i&lt;=n;i++) //initialize binary indexed tree bit[i]=0ll; int r ; for(int i=0;i&lt;n-1;i++) &#123; cin&gt;&gt;x&gt;&gt;y; if(i==0) r=x; //the first one is root al[x].push_back(y); &#125; dfs(r); cout&lt;&lt;similar_pair&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
        <tag>Hackerrank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Implicit Treap]]></title>
    <url>%2F2016%2F05%2F29%2FImplicit%20Treap%2F</url>
    <content type="text"><![CDATA[Hackerrank: Array and simple queriesGiven two numbers N and M. N indicates the number of elements in the array A[](1 - indexed) and M indicates number of queries. You need to perform two types of queries on the array A[]. You are given M queries. Queries can be of two types, type 1 and type 2. Type 1 queries are represented as 1 i j : Modify the given array by removing elements from i to j and adding them to the front. Type 2 queries are represented as 2 i j : Modify the given array by removing elements from i to j and adding them to the back. Your task is to simply print of the resulting array after the execution of queries followed by the resulting array. Note While adding at back or front the order of elements is preserved. Input Format First line consists of two space-separated integers, N and M. Second line contains N integers, which represent the elements of the array.M queries follow. Each line contains a query of either type 1 or type 2 in the form i j Constraints $1\leqslant N, M \leqslant 10^5$ $1\leqslant A[i] \leqslant 10^9$ $1\leqslant i\leqslant j\leqslant N$ Output Format Print the absolute value i.e. $abs(A[i]-A[j])$in the first line.Print elements of the resulting array in the second line. Each element should be seperated by a single space. Sample Input 8 4 1 2 3 4 5 6 7 8 1 2 4 2 3 5 1 4 7 2 1 4 Sample Output 1 2 3 6 5 7 8 4 1 Explanation Given array is {1,2,3,4,5,6,7,8} . After execution of query 1 2 4 , the array becomes {2,3,4,1,5,6,7,8} . After execution of query 2 3 5 , the array becomes {2,3,6,7,8,4,1,5}. After execution of query 1 4 7, the array becomes {7,8,4,1,2,3,6,5}. After execution of query 2 1 4, the array becomes {2,3,6,5,7,8,4,1}. Now $|A[1]-A[N]|$ is $|(2-1)|$ i.e. $1$ and the array is 23657841 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;iostream&gt;using namespace std;struct Node&#123; /* treap = tree + heap 各Node的priority是隨機給的，以此建立一個穩定的log(n) tree parent.priority&lt;children.priority */ int priority; //存取array element int value; /* the method using here is also called implicit treap, since we store size not index size = the number of nodes below the nodes + 1 = left.size + right.size + 1 利用size來得到index(所以才叫implicit)，若為nullptr則為0，若為葉子則為1，透過Inorder使treap取代一array */ int size; //left tree and right tree Node *l, *r;&#125;;//return the size of the nodeint sz(Node *t)&#123; return t? t-&gt;size:0;&#125;//update size of the node when split or merge is donevoid update_size(Node *t)&#123; if(t) t-&gt;size = sz(t-&gt;l)+1+sz(t-&gt;r);&#125;//used to split a tree into left and right tree//left contains index from 0 ~ key, right contains index form key+1 ~ Nvoid split(Node *t, int key, Node *&amp;left, Node *&amp;right, int &amp;add)&#123; if(t==nullptr)&#123; left = right = nullptr; return; &#125; //需考慮到因為看整棵tree是利用inorder，所以右邊的tree還需要加root的pos才是對的 int cur_pos = add+sz(t-&gt;l)+1; //左邊的樹有包含到該key //t為subtree，需要被檢查的部分，利用copy pointer而已 //因為t的left tree 必定小於key，所以傳遞t的right tree到下一個function以檢查，而因為此t小於 //等於key，所以屬於left的 if(cur_pos&lt;=key) add = cur_pos, split(t-&gt;r, key, t-&gt;r, right, add), left=t; //因為t大於key，所以屬於right的 else split(t-&gt;l, key, left, t-&gt;l, add), right = t; //完成merge後需要更新該節點的size update_size(t);&#125;//merge left tree and right into a treevoid merge(Node *&amp;t, Node *left, Node *right)&#123; if(!left || !right) t = left?left:right; //merge時，需要考慮到該treap是heap，所以組合時仍需要考慮priorty，以維持該tree為log(n)， //而merge時， 已確信兩個left and right are in correct order， //而left之index在right的index 之前，透過交換left and right這個來解本題的move front or back else if(left-&gt;priority&lt;=right-&gt;priority) merge(left-&gt;r, left-&gt;r, right), t = left; else merge(right-&gt;l, left, right-&gt;l), t = right; update_size(t);&#125;void insert(Node *&amp;t, int pos, int value)&#123; Node *left, *right; int add=0; split(t, pos-1, left, right, add); Node *newnode = new Node; newnode-&gt;value = value; newnode-&gt;size = 1; newnode-&gt;priority = int(rand()); newnode-&gt;l = nullptr; newnode-&gt;r = nullptr; t = nullptr; Node *t1; merge(t1, left, newnode); merge(t, t1, right);&#125;void inOrder(Node *root)&#123; if(root!=nullptr)&#123; inOrder(root-&gt;l); cout&lt;&lt;root-&gt;value&lt;&lt;" "; inOrder(root-&gt;r); &#125;&#125;int main()&#123; int number; int total_cmd; cin&gt;&gt;number; cin&gt;&gt;total_cmd; Node *head = nullptr; for(int j=1; j&lt;=number; j++)&#123; int input; cin&gt;&gt;input; insert(head, j, input); &#125; while(total_cmd&gt;0)&#123; int cmd; //left index and right index int left_x, right_x; cin&gt;&gt;cmd; cin&gt;&gt;left_x; cin&gt;&gt;right_x; Node *right = nullptr, *left = nullptr, *mid = nullptr; Node *mid_t = nullptr; int add=0; split(head, left_x-1, left, mid_t, add); split(mid_t, right_x, mid, right, add); head = nullptr; Node *result1 = nullptr; switch(cmd)&#123; case 1: merge(result1, mid, left); merge(head, result1, right); break; case 2: merge(result1, left, right); merge(head, result1, mid); break; &#125; total_cmd--; &#125; int value_1=0; int value_2=0; Node *tmp_1 = head; Node *tmp_2 = head; while(tmp_1!=nullptr)&#123; value_1 = tmp_1-&gt;value; tmp_1 = tmp_1-&gt;l; &#125; while(tmp_2!=nullptr)&#123; value_2 = tmp_2-&gt;value; tmp_2 = tmp_2-&gt;r; &#125; if(value_1&gt;=value_2) cout&lt;&lt;value_1-value_2&lt;&lt;endl; else cout&lt;&lt;value_2-value_1&lt;&lt;endl; inOrder(head); cout&lt;&lt;endl; return 0;&#125; reference: https://threads-iiith.quora.com/Treaps-One-Tree-to-Rule-em-all-Part-2]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
        <tag>Hackerrank</tag>
      </tags>
  </entry>
</search>
